#!/usr/bin/env python

'''
Running this script:
Ensure you have Python 3.12.11 or later
Navigate to directory and run `python work`
If you would like to run this without navigating to directory, add the directory to PATH

Logs:
To find logs, navigate to $HOME/logs/work

:3

- Saw on jvscholz YouTube and wanted to recreate it for fun
- link to video: https://www.youtube.com/watch?v=2eVGQreqa20
'''

import os
import sys
import time
import shutil
import random
import re
import logging
import argparse
from datetime import datetime, timedelta
from pathlib import Path


# ---------------- ANSI colors ----------------
class bcolors:
    black      = '\033[38;5;234m'
    dark1      = '\033[38;5;235m'
    dark2      = '\033[38;5;236m'
    dark3      = '\033[38;5;237m'
    dark4      = '\033[38;5;239m'
    gray       = '\033[38;5;244m'
    light0     = '\033[38;5;223m'
    light1     = '\033[38;5;230m'
    light2     = '\033[38;5;229m'
    light3     = '\033[38;5;180m'
    red        = '\033[38;5;167m'
    green      = '\033[38;5;142m'
    yellow     = '\033[38;5;214m'
    blue       = '\033[38;5;109m'
    purple     = '\033[38;5;175m'
    aqua       = '\033[38;5;108m'
    orange     = '\033[38;5;208m'

    ENDC       = '\033[0m'
    BOLD       = '\033[1m'
    UNDERLINE  = '\033[4m'


ANSI_ESCAPE = re.compile(r'\x1B\[[0-?]*[ -/]*[@-~]')


# ---------------- Path Setup ----------------------
directory_path = Path.home() / "logs" / "work"

if not directory_path.exists():
    directory_path.mkdir(parents=True)
    print(f"{bcolors.green}Created directory:{bcolors.ENDC} {directory_path}")
else:
    print(f"{bcolors.gray}Using existing directory:{bcolors.ENDC} {directory_path}")

time.sleep(2)


# ---------------- Terminal helpers ----------------
def clear_terminal():
    os.system('cls' if sys.platform.startswith('win') else 'clear')


def restore():
    print(f'{bcolors.ENDC}')
    print('\033[?25h', end="")


def print_centered_text(text):
    """Print a single text block centered vertically and horizontally."""
    size = shutil.get_terminal_size()
    term_width, term_height = size.columns, size.lines

    lines = text.splitlines()
    top_padding = max(0, (term_height - len(lines)) // 2)

    centered_lines = []
    for line in lines:
        visual_len = len(ANSI_ESCAPE.sub('', line))
        left_padding = max(0, (term_width - visual_len) // 2)
        centered_lines.append(" " * left_padding + line)

    print("\n" * top_padding + "\n".join(centered_lines))


# ---------------- Classes ----------------
class Art:
    def __init__(self, template):
        self.lines = template.splitlines()
        self.max_art_width = max(len(ANSI_ESCAPE.sub('', line)) for line in self.lines)

    def center(self, term_width):
        centered_lines = []
        for line in self.lines:
            # Center relative to terminal but preserve shape
            left_padding = max(0, (term_width - self.max_art_width) // 2)
            centered_lines.append(" " * left_padding + line)
        return "\n".join(centered_lines)


class Quote:
    def __init__(self, text, color=bcolors.green):
        self.text = f"{color}{text}{bcolors.ENDC}"

    def center(self, term_width):
        visual_len = len(ANSI_ESCAPE.sub('', self.text))
        left_padding = max(0, (term_width - visual_len) // 2)
        return " " * left_padding + self.text


class TimeLine:
    def __init__(self, left_time, countdown, right_time):
        self.left_time = left_time
        self.countdown = countdown
        self.right_time = right_time

    def center(self, term_width):
        line = f"{bcolors.purple}{bcolors.UNDERLINE}{self.left_time}{bcolors.ENDC} | {bcolors.aqua}goal pending{bcolors.ENDC} {bcolors.yellow}{self.countdown}{bcolors.ENDC} | {bcolors.purple}{self.right_time}{bcolors.ENDC}"
        visual_len = len(ANSI_ESCAPE.sub('', line))
        left_padding = max(0, (term_width - visual_len) // 2)
        return " " * left_padding + line


class Reflection:
    def __init__(self, duration, description):
        self.duration = duration
        self.description = description

    def write_to_log(self):
        reflection_logger.info(f"Duration: {self.duration} | Reflection: {self.description}")


def format_duration(seconds):
    hours, remainder = divmod(int(seconds), 3600)
    minutes, secs = divmod(remainder, 60)
    parts = []
    if hours > 0:
        parts.append(f"{hours}h")
    if minutes > 0:
        parts.append(f"{minutes}m")
    if secs > 0 or not parts:
        parts.append(f"{secs}s")
    return " ".join(parts)


# ---------------- Reflection ----------------------
def reflection_prompt(duration):
    try:
        restore()
        print_centered_text(f'''{bcolors.blue}Well done! It is important to reflect on your work and see ways in which you can improve.
        It is also a good time to reflect on areas that you are doing well in!{bcolors.ENDC}''')
        description = input("Enter your reflection for this session:\n")
        formatted_duration = format_duration(duration)
        reflection = Reflection(formatted_duration, description)
        reflection.write_to_log()
        print("Thank you!\n")
        print(f"Log saved to: {bcolors.gray}{directory_path}/reflections.log{bcolors.ENDC}")
    except KeyboardInterrupt:
        print("\nReflection skipped.")
    finally:
        restore()


# ---------------- Display function ----------------
def display_block(art, quote, time_line):
    size = shutil.get_terminal_size()
    term_width, term_height = size.columns, size.lines

    art_block = art.center(term_width).splitlines()
    quote_line = quote.center(term_width)
    time_line_line = time_line.center(term_width)

    block_lines = art_block + [quote_line] + [time_line_line]

    # Vertical centering
    top_padding = max(0, (term_height - len(block_lines)) // 2)

    print("\n" * top_padding + "\n".join(block_lines))


# ----------------- Duration Helper ----------------
def parse_duration(value):
    match = re.match(r'(?:(\d+)h)?(?:(\d+)m)?(?:(\d+)s)?$', value)
    if not match:
        raise argparse.ArgumentTypeError("Duration must be like '1h30m', '45m', or '300s'.")
    hours, minutes, seconds = match.groups(default="0")
    return int(hours) * 3600 + int(minutes) * 60 + int(seconds)


# ---------------- Live display ----------------
def live_display(duration):
    start_time = datetime.now()
    end_time = start_time + timedelta(seconds=duration)

    art_template = rf'''{bcolors.aqua}         .        .            |       .        .        .
              *        .       |   .        .
        .                     /-\     .           .   .
 .               .    .      |"""|              :        .
         .                  /"""""\  .      *       |>.
                           | # # # |     .        /\|  ___
    __     ___   ___   .   |# # # #| ___      ___/<>\ |:::|
  / ""|  __|~~| |"""|      |# # # #||"""|  __|"""|^^| |:::|
 /""""| |::|''|~~~~||_____ |# # # #||"""|-|::|"""|''|_|   |
 |""""| |::|''|""""|:::::| |# # # #||"""|t|::|"""|''|"""""|
 |""""|_|  |''|""""|:::::| |# # # #||"""|||::|"""|''""""""|
 |""""|::::|''|""""|:::::| |# # # #||"""|||::|"""|''""""""|{bcolors.ENDC}

{{quote}}
{{time_line}}'''

    art = Art(art_template.replace("{quote}", "").replace("{time_line}", ""))

    quotes = [
        "Keep going — small steps add up.",
        "Stay focused. Time is your ally.",
        "You're building momentum.",
        "Progress > perfection.",
        "Discipline beats motivation."
    ]

    left_time = start_time.strftime("%Y-%m-%d %H:%M:%S")
    right_time = end_time.strftime("%Y-%m-%d %H:%M:%S")
    quote_text = random.choice(quotes)
    next_quote_time = time.time() + random.randint(900, 1800)

    try:
        while True:
            now = datetime.now()
            remaining = end_time - now
            if remaining.total_seconds() <= 0:
                break

            total_seconds = int(remaining.total_seconds())
            hours, remainder = divmod(total_seconds, 3600)
            minutes, seconds = divmod(remainder, 60)
            countdown = f"{hours}h {minutes}m {seconds}s"

            if time.time() >= next_quote_time:
                quote_text = random.choice(quotes)
                next_quote_time = time.time() + random.randint(900, 1800)

            clear_terminal()
            quote = Quote(quote_text)
            time_line = TimeLine(left_time, countdown, right_time)
            display_block(art, quote, time_line)

            time.sleep(1)

    except KeyboardInterrupt:
        elapsed = datetime.now() - start_time
        clear_terminal()
        print_centered_text(f"{bcolors.yellow}⚠️  Timer interrupted! ⚠️\nElapsed: {str(elapsed).split('.')[0]}\nRemaining: {str(end_time - datetime.now()).split('.')[0]}{bcolors.ENDC}")
        interrupt_logger.info(f"⚠️  Timer interrupted! ⚠️\nElapsed: {str(elapsed).split('.')[0]}\nRemaining: {str(end_time - datetime.now()).split('.')[0]}")
        restore()
        sys.exit(0)

    clear_terminal()
    print_centered_text(f"{left_time} | ✅ goal complete | {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    success_logger.info(f"{left_time} | ✅ goal complete | {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\nduration: {duration}")
    reflection_prompt(duration)


# ---------------- Logging ----------------
success_logger = logging.getLogger('success_logger')
success_logger.setLevel(logging.INFO)
success_handler = logging.FileHandler(Path.home() / 'logs' / 'work' / 'success.log')
success_formatter = logging.Formatter('%(asctime)s - %(message)s')
success_handler.setFormatter(success_formatter)
success_logger.addHandler(success_handler)

interrupt_logger = logging.getLogger('interrupt_logger')
interrupt_logger.setLevel(logging.INFO)
interrupt_handler = logging.FileHandler(Path.home() / 'logs' / 'work' / 'interrupted.log')
interrupt_formatter = logging.Formatter('%(asctime)s - %(message)s')
interrupt_handler.setFormatter(interrupt_formatter)
interrupt_logger.addHandler(interrupt_handler)

reflection_logger = logging.getLogger('reflection_logger')
reflection_logger.setLevel(logging.INFO)
reflection_handler = logging.FileHandler(Path.home() / 'logs' / 'work' / 'reflections.log')
reflection_formatter = logging.Formatter('%(asctime)s - %(message)s')
reflection_handler.setFormatter(reflection_formatter)
reflection_logger.addHandler(reflection_handler)


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description="Run a focused work session timer with ASCII display."
    )
    parser.add_argument(
        "-d", "--duration",
        type=parse_duration,
        default=14400,
        help="Duration of the session (e.g. 1h30m, 25m, 300s)"
    )
    args = parser.parse_args()

    print('\033[?25l', end="")  # hide cursor
    live_display(duration=args.duration)
